<meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

						  **Week 3 Report**


by Julian Manyika, Peyton Greve, Kyle Sandell, Brett Allen, Alex Cho and Haran Nadarajah


# Infinite Run: game class utilizing ball and obstacle objects

**Deliverable**: The user should be able to navigate to Infinite run, and open up the game. In the game, the user presses start, and obstacles begin to go down the screen. The game just redraws the obstacles, making it look like they're coming down the screen. The spawning of obstacles should be random



# Infinite Run: ball and obstacle classes

**Deliverable**: The ball stays at the same height on the screen, and the user tilts the device to move left or right to move it left or right. The obstacles should only have an updatable location, and won't depend on imu input.



# Single Player Trivia: game class

**Deliverable**: Create trivia game class that includes ability to answer multiple choice and true or false question. Keeps track of score using point system where as points increase so does happiness.



# Basic login

**Deliverable**: user should have to enter their username every time they open up their device, or they can create a timagotchi with a new username



# Hunger and Happiness meters, login key icon

**Deliverable**: Hunger meter on the left of the beaver icon, happiness on the right. Happiness being red, hunger being green



# Connecting endpoints with timagotchi

**Deliverable**: Connect each of the menus and their various actions/server hits to work and actually update the database



# Menu-to-menu connection

**Deliverable**: Connect the menus such that as soon as the user turns it on, they can get from creating a user/logging in to the main menu and between said menus

An important part of menu and object integration into the larger system was modifying the update functions of each object so that they'd return useful information that would then help determine system state. We called this the *flag*

* a non-zero flag is meant to indicate a system state change
* otherwise, the state remains the same, and the current object, whether it be a game, menu, etc..., keeps taking in sensor reads and makes decisions accordingly.

Here is the code for the system fsm.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void fsm(int b1_delta, int b2_delta) {
	switch (state) {
	  case LANDING:
		if (b2_delta == -3) {
		  state = LOGIN;
		} else if (b2_delta == -2) {
		  state = INIT;
		}
		break;
	  case LOGIN:
		flag = login.update(b1_delta, b2_delta);
		if (flag != 0) {
		  state = NAV;
		  menu.displayHome();
		}
		break;
	  case INIT:
		flag = timCreator.update(abs(b1_delta), abs(b2_delta));
		if (flag != 0) {
		  state = NAV;
		  menu.displayHome();
		}
		break;
	  case NAV:
		flag = menu.update(b1_delta, b2_delta);
		if (flag == single_trivia_flag) {
		  state = SP_TRIVIA;
		  Serial.println("Problem?");
		  sp_trivia.initialize(username, network, password, tft, false);
		} else if (flag == multi_trivia_flag) {
		  state = MP_TRIVIA;
		  //trivia = TriviaGame(multi);
		} else if (flag == infinite_run_flag) {
		  state = INFINITE;
		  imu_activated = true;
		  //infinite = InfiniteRun();
		}
		break;
	  case SP_TRIVIA:
		flag = sp_trivia.update(b1_delta, b2_delta);
		if (flag != 0) {
		  state = NAV;
		  menu.displayHome();
		}
		break;
	  case MP_TRIVIA:
		//flag = mp_trivia.update(b1_delta, b2_delta);
		if (flag != 0) {
		  state = NAV;
		  menu.displayHome();
		}
		break;
	  case INFINITE:
		flag = 0;
		
		//flag = infinite.update(b1_delta, b2_delta);
		if (flag != 0 or b1_delta != 0) {
		  state = NAV;
		  imu_activated = false;
		  menu.displayHome();
		}
		break;
	}
	if (flag != 0) {
	  Serial.println(flag);
	}
	flag = 0;
  }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



<!--?prettify?--></LOOP_PERIOD>
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>